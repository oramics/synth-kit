{"version":3,"file":"synth-kit.js","sources":["../lib/synth.js","../lib/kit/gain.js","../lib/kit/gain-envelope.js","../lib/kit/mono-buffer.js","../lib/kit/source.js","../lib/kit/noise.js","../lib/kit/sample.js","../lib/kit/pulse.js","../lib/kit/vca.js","../lib/kit/osc.js","../lib/kit/vco.js","../lib/kit/vcf.js","../lib/kit/wave-shaper.js","../lib/kit/soft-clipper.js","../lib/instruments/kick.js","../lib/kit/filter.js","../lib/instruments/snare.js","../lib/kit/osc-bank.js","../lib/instruments/hihat.js","../lib/instruments/cowbell.js","../lib/instruments/conga.js","../lib/instruments/tom.js","../lib/instruments/monosynth.js","../lib/kit/feedback-comb-filter.js","../lib/instruments/pluck.js","../lib/instruments/tonewheel.js"],"sourcesContent":["// const isString = (o) => typeof o === \"string\"\nconst isFn = (o) => typeof o === \"function\"\nconst { exp, E } = Math\n\nexport function ampToGain (amp) {\n  return (exp(amp) - 1) / (E - 1)\n}\n\nexport function instrument (ac, config) {\n  const inst = {}\n  const names = Object.keys(config)\n\n  // create nodes\n  names.forEach(key => {\n    const Node = config[key][0]\n    inst[key] = typeof Node === \"function\" ? Node(ac) : Node\n  })\n  // connect nodes\n  names.forEach(key => {\n    const to = config[key][1]\n    const node = inst[key]\n    if (to === \"output\") connectWith(inst, node)\n    else connect(node, inst[to])\n  })\n\n  // API\n  // update: change the state of the instrument\n  inst.update = (state, time) => {\n    time = time || ac.currentTime\n    if (state) {\n      names.forEach(key => {\n        inst[key].update(state[key], time)\n      })\n    }\n    return inst\n  }\n  // inspect: get the current state of the instrument\n  inst.inspect = () => names.reduce((state, name) => {\n    state[name] = inst[name].inspect()\n    return state\n  }, {})\n  return inst\n}\n\nexport function createAudioNode (ac, type, params, initParam) {\n  const node = ac[\"create\" + type](initParam)\n  node.update = (state) => {\n    if (state) {\n      params.forEach(name => {\n        plug(node, name, state[name])\n      })\n    }\n    return node\n  }\n  node.inspect = () => params.reduce((state, name) => {\n    state[name] = inspect(node, name)\n    return state\n  }, {})\n  return node\n}\n\n// Get the value of a node parameter\nexport function inspect (node, name) {\n  const value = node[name]\n  return value && value.value !== undefined ? value.value : value\n}\n\n/**\n * Update a node property with a value. If the property is a parameter and\n * the value is a node, it will connect them\n */\nexport function plug (node, name, value) {\n  const target = node[name]\n  if (isFn(value)) value = value()\n  if (value === undefined || target === undefined) {\n    // ignore\n  } else if (target.value !== undefined) {\n    // it's a parameter\n    if (isFn(value.connect)) {\n      value.connect(target)\n    } else {\n      target.value = value\n      target.setValueAtTime(value, 0)\n    }\n  } else {\n    // replace the old value with a new one\n    node[name] = value\n  }\n}\n\nfunction connect (node, dest) {\n  if (dest) node.connect(dest)\n}\n\n/**\n * Set the output of a node (by creating a new connect function)\n */\nexport function connectWith (inst, node) {\n  inst.connect = (dest) => {\n    if (dest === true) dest = node.context.destination\n    node.connect(dest)\n    return inst\n  }\n}\n\nexport function withDefaults (config, defaults) {\n  return config ? Object.assign({}, defaults, config) : defaults\n}\n\n/**\n * Trigger an ADSR envelope over a param\n */\nexport function triggerAdsr (time, param, adsr) {\n  param.cancelScheduledValues(0)\n\n  // attack phase\n  const attack = adsr.attack || 0.01\n  const peak = adsr.peak || 1\n  param.setValueAtTime(0, time)\n  time += attack\n  console.log(\"attack\", attack, peak, time)\n  param.linearRampToValueAtTime(peak, time)\n\n  // decay phase\n  const decay = adsr.decay || 0.01\n  const sustain = adsr.sustain || 0\n  time += decay\n  param.linearRampToValueAtTime(sustain, time)\n\n  // hold phase\n  const hold = adsr.hold || 0\n  if (hold) {\n    time += hold\n    param.setValueAtTime(sustain, time)\n  }\n\n  const release = time => {\n    if (sustain) {\n      param.setValueAtTime(time, sustain)\n      const release = adsr.release || 0\n      console.log(\"Trigger release\", release, time)\n      time += release\n      param.exponentialRampToValueAtTime(0.00001, time)\n    }\n  }\n\n  // trigger release if hold is specified\n  if (hold) {\n    release(time)\n  }\n\n  return release\n}\n","// # Gain\nimport { createAudioNode } from \"../synth\"\n\n// Gain produces changes in volume\n\n/**\n * Create a Gain node.\n */\nexport default function Gain (ac, state) {\n  return createAudioNode(ac, \"Gain\", Gain.params).update(state)\n}\nGain.params = [\"gain\"]\n","import { triggerAdsr } from \"../synth\"\nimport Gain from \"./gain\"\n\nconst SILENCE = { gain: 0 }\n/**\n * Create a Gain envelope. Any audio source can be connected to an\n * audio envelope.\n *\n * @example\n * const [osc, adsr] = connect(Osc(ac), GainEnvelope(ac))\n * adsr.trigger()\n */\nexport default function GainEnvelope (ac, state) {\n  const env = Gain(ac, SILENCE)\n  state = Object.assign({}, GainEnvelope.defaultState, state)\n\n  env.update = (newState) => {\n    state = Object.assign(state, newState)\n    return env\n  }\n  env.inspect = () => state\n\n  env.trigger = function (time, dur) {\n    if (!time) time = ac.currentTime\n    const release = triggerAdsr(time, env.gain, state)\n    if (dur) release(time + dur)\n    return release\n  }\n  return env\n}\n\nGainEnvelope.params = [\n  \"base\",\n  \"peak\",\n  \"attack\",\n  \"decay\",\n  \"sustain\",\n  \"release\",\n]\n\n// default values\nGainEnvelope.defaultState = {\n  peak: 1,\n  attack: 0.01,\n  decay: 0.2,\n}\n","// # Buffer (Mono)\n\n/**\n * Create a MonoBuffer using a generator function\n */\nexport default function MonoBuffer (ac, samples, generator, inverse = false) {\n  const buffer = ac.createBuffer(1, samples, ac.sampleRate)\n  const data = buffer.getChannelData(0)\n  for (let i = 0; i < samples; i++) {\n    data[i] = generator(inverse ? samples - i : i)\n  }\n  return buffer\n}\n","// # Source\nimport { createAudioNode } from \"../synth\"\n\n// Create a node that plays audio from a buffer\n\n/**\n * Create a (Buffer)Source node\n */\nexport default function Source (ac, buffer, state) {\n  const source = createAudioNode(ac, \"BufferSource\", Source.params)\n  source.update(state)\n  source.buffer = buffer\n  return source\n}\n\nSource.params = [\"detune\", \"loop\", \"loopStart\", \"loopEnd\", \"playbackRate\"]\n","// # Noise\nimport MonoBuffer from \"./mono-buffer\"\nimport Source from \"./source\"\n\n/**\n * Create a Noise oscillator\n *\n * @param {AudioContext} ac\n * @param {Object} [config]\n * - type: the noise type. Can be \"white\" (by default)\n * - duration: the duration in seconds\n * @return {AudioNode} the noise node\n */\nexport default function Noise (ac, config) {\n  config = Object.assign({}, Noise.defaults, config)\n  const samples = config.duration * ac.sampleRate\n  const buffer = MonoBuffer(ac, samples, () => Math.random() * 2 - 1)\n  const noise = Source(ac, buffer, { loop: true })\n  noise.start()\n  return noise\n}\nNoise.defaults = {\n  duration: 1,\n  loop: true\n}\n","// # Sample\nimport Gain from \"./gain\"\nimport Source from \"./source\"\n\n// A sample is a re-triggerable audio buffer source.\n\n/**\n * Create a Sample\n *\n * @param {AudioContext} context\n * @param {AudioBuffer} buffer\n * @param {Object} [state]\n */\nexport default function Sample (ac, buffer, config) {\n  const sample = Gain(ac)\n\n  sample.trigger = (time, dur) => {\n    if (!time) time = ac.currentTime\n    const source = Source(ac, buffer, config)\n    source.connect(sample)\n    source.onended = () => {\n      if (sample.onended) sample.onended()\n      source.disconnect()\n    }\n    source.start(time)\n  }\n  return sample\n}\n\nSample.state = {\n  gain: 0.8\n}\n","// # Pulse\nimport MonoBuffer from \"./mono-buffer\"\nimport Sample from \"./sample\"\n\n/**\n * Create a Pulse audio node\n *\n * @param {AudioContext} ac\n * @param {Object} [config]\n * - type: the pulse type. Can be \"white\" (by default)\n * - duration: the duration in seconds\n * @return {AudioNode} the pulse node\n */\nexport default function Pulse (ac, config) {\n  config = Object.assign({}, Pulse.defaults, config)\n  const samples = config.duration * ac.sampleRate\n  const buffer = MonoBuffer(ac, samples, () => Math.random() * 2 - 1)\n  const pulse = Sample(ac, buffer)\n  return pulse\n}\nPulse.defaults = {\n  duration: 0.001\n}\n","// Voltage controlled amplified\nimport Gain from \"./gain\"\n\n/**\n * Create a VCA\n */\nexport default function VCA (ac, config) {\n  const vca = Gain(ac, config)\n  return vca\n}\n","// # Oscillator\nimport { createAudioNode } from \"../synth\"\n\n/**\n * Create an Oscillator\n * A oscillator is always started\n */\nexport default function Osc (ac, state, start = true) {\n  const osc = createAudioNode(ac, \"Oscillator\", Osc.params)\n  if (start) osc.start(+start)\n  return osc\n}\nOsc.params = [\"type\", \"frequency\", \"detune\"]\n","// # Voltage Controlled Oscillator\nimport Osc from \"./osc\"\n\n/**\n * Create a VCO\n */\nexport default function VCO (ac, config) {\n  return Osc(ac, config)\n}\n","// # Voltage Controlled Filter\nimport { createAudioNode, triggerAdsr } from \"../synth\"\n\n// A voltage controlled filter is a BiquadFilter with a\n// AD (attack-decay) envelope connected to it's frequency\n\n/**\n * Create a VCF\n */\nexport default function VCF (ac, state) {\n  const filter = createAudioNode(ac, \"BiquadFilter\", VCF.params)\n  // set the default parameters so plug work with them\n  filter.attack = 0.01\n  filter.decay = 0.1\n  filter.octaves = 2\n\n  filter.trigger = function (time, dur) {\n    if (!time) time = ac.currentTime\n    this.base = this.frequency.value\n    this.peak = this.base * this.octaves\n    const release = triggerAdsr(time, filter.frequency, filter)\n    if (dur) release(time + dur)\n    return release\n  }\n  return filter.update(state)\n}\nVCF.params = [\"type\", \"frequency\", \"detune\", \"Q\",\n  \"attack\", \"decay\", \"octaves\"]\nVCF.defaults = {\n  type: \"lowpass\",\n  frequency: 880,\n  attack: 0.1,\n  decay: 0.5,\n  octaves: 2\n}\n","// # WaveShaper\n\n/**\n * Create a WaveShaper node.\n */\nexport default function WaveShaper (ac, curve, oversample = \"none\") {\n  const shaper = ac.createWaveShaper()\n  shaper.curve = curve\n  shaper.oversample = oversample\n  return shaper\n}\n","// # SoftClipper\nimport { createAudioNode } from \"../synth\"\nimport WaveShaper from \"./wave-shaper\"\n\n// ## Structure\n// Input -> Gain -> WaveShaper -> Output\n\nlet curve = null\n\n/**\n * Create a SoftClipper\n */\nexport default function SoftClipper (ac, state) {\n  const clipper = createAudioNode(ac, \"Gain\", SoftClipper.params)\n  clipper.drive = clipper.gain\n  if (!curve) curve = createSoftClipperCurve()\n  const shaper = WaveShaper(ac, curve, \"2x\")\n  clipper.connect(shaper)\n  clipper.connect = shaper.connect.bind(shaper)\n  return clipper.update(state)\n}\nSoftClipper.params = [\"drive\"]\n\nfunction createSoftClipperCurve () {\n  const n = 65536\n  const curve = new Float32Array(n)\n  for (let i = 0; i < n; i++) {\n    const x = (i - (n / 2)) / (n / 2)\n    curve[i] = Math.tanh(x)\n  }\n  return curve\n}\n","// # Kick\nimport { instrument } from \"../synth\"\nimport Osc from \"../kit/osc\"\nimport Gain from \"../kit/gain\"\nimport Pulse from \"../kit/pulse\"\nimport SoftClipper from \"../kit/soft-clipper\"\nimport GainEnvelope from \"../kit/gain-envelope\"\nimport VCF from \"../kit/vcf\"\n\n// A simple kick instrument\n\n/**\n * Create a Kick\n */\nexport function Kick (ac, state) {\n  state = Object.assign({}, Kick.defaults, state)\n\n  // ## Architecture\n  const kick = instrument(ac, {\n    // An oscillator\n    oscillator: [ Osc, \"envelope\" ],\n    // A pulse trigger (click)\n    click: [ Pulse, \"envelope\" ],\n    // The gain envelope\n    envelope: [ GainEnvelope, \"vcf\" ],\n    // A filter with envelope\n    vcf: [ VCF, \"clipper\" ],\n    // A soft distortion\n    clipper: [ SoftClipper, \"amp\" ],\n    // The output amplifier\n    amp: [ Gain, \"output\" ],\n  }).update(state)\n\n  kick.trigger = (time) => {\n    kick.click.trigger(time)\n    kick.envelope.trigger(time)\n  }\n\n  return kick\n}\n\n// ## Default configuration\nKick.defaults = {\n  oscillator: {\n    type: \"sine\",\n    frequency: 48,\n  },\n  envelope: {\n    attack: 0.1,\n    decay: 0.2,\n  },\n  vcf: {\n    type: \"lowpass\",\n    frequency: 48,\n    envelope: {\n      base: 48,\n      peak: 100,\n      attack: 0.001,\n      decay: 0.60,\n    }\n  },\n  amp: {\n    gain: 1,\n  }\n}\n\nexport default Kick\n","/** @module kit */\nimport { createAudioNode } from \"../synth\"\n\n/**\n * Create a Filter\n * @param {AudioContext} context\n * @param {Object} [config]\n */\nexport default function Filter (ac, state) {\n  return createAudioNode(ac, \"BiquadFilter\", Filter.params).update(state)\n}\nFilter.params = [\"type\", \"frequency\", \"detune\", \"Q\"]\n","// # Snare\nimport { instrument } from \"../synth\"\nimport Osc from \"../kit/osc\"\nimport Noise from \"../kit/noise\"\nimport Filter from \"../kit/filter\"\nimport Gain from \"../kit/gain\"\nimport GainEnvelope from \"../kit/gain-envelope\"\n\n// A snare modeled after the 808 design\n\n/**\n * Create the Snare\n */\nexport function Snare (ac, state) {\n  state = Object.assign({}, Snare.defaults, state)\n  // # Architecture\n  // <img alt=\"808 snare\" src=\"http://media.soundonsound.com/sos/apr02/images/synth9_10.gif\" style=\"width: 100%;\" />\n  const snare = instrument(ac, {\n    // The _snappy_ oscillators\n    osc1: [Osc, \"oscEnv\"],\n    osc2: [Osc, \"oscEnv\"],\n    // The AD envelope for the oscillators\n    oscEnv: [GainEnvelope, \"amp\"],\n    // White noise generator\n    noise: [Noise, \"noiseFilter\"],\n    // The noise filter\n    noiseFilter: [Filter, \"noiseEnv\"],\n    // The AD envelope for the noise\n    noiseEnv: [GainEnvelope, \"amp\"],\n    // Output\n    amp: [Gain, \"output\"],\n  }).update(state)\n\n  snare.trigger = (time) => {\n    snare.oscEnv.trigger(time)\n    snare.noiseEnv.trigger(time)\n  }\n\n  return snare\n}\n\nSnare.defaults = {\n  osc1: {\n    type: \"sine\",\n    frequency: 238,\n  },\n  osc2: {\n    type: \"sine\",\n    frequency: 476,\n  },\n  oscEnv: {\n    peak: 0.4,\n    attack: 0.01,\n    decay: 0.1,\n  },\n  noise: {\n    type: \"white\",\n  },\n  noiseFilter: {\n    type: \"highpass\",\n    frequency: 4000,\n  },\n  noiseEnv: {\n    attack: 0.01,\n    decay: 0.08,\n  },\n  amp: {\n    gain: 0.5,\n  },\n}\n\nexport default Snare\n","// # Oscillator Bank\nimport Gain from \"./gain\"\nimport Osc from \"./osc\"\n\nconst conn = (src, dest) => {\n  src.connect(dest)\n  return src\n}\n\n/**\n * Create a OscBank\n */\nexport default function OscBank (ac, ratios, config) {\n  if (!ratios) throw Error(\"OscBank requires an array 'ratios' in constructor\")\n\n  // Setup internal state\n  const state = Object.assign({}, OscBank.defaults, config)\n  initState(state, ratios)\n\n  // Create the audio nodes\n  const output = Gain(ac)\n  const amps = ratios.map(_ => {\n    const amp = conn(Gain(ac), output)\n    return amp\n  })\n  const oscs = amps.map((gain, i) => {\n    const osc = conn(Osc(ac), gain)\n    osc.type = state.types[i]\n    return osc\n  })\n  const bank = { output, amps, oscs }\n\n  // API\n  bank.connect = (dest) => conn(output, dest)\n  bank.update = (config, time) => {\n    if (typeof config === \"number\" || typeof config === \"string\") {\n      state.frequency = +config\n      updateFrequencies(bank, state, time)\n    } else if (config) {\n      time = time || ac.currentTime\n      if (config.gains) {\n        updateArray(state.gains, config.gains)\n        updateGains(bank, state, time)\n      }\n      if (config.frequency !== undefined) {\n        state.frequency = config.frequency\n        updateFrequencies(bank, state, time)\n      }\n    }\n    return bank\n  }\n  bank.inspect = () => state\n  return bank.update(state)\n}\nOscBank.defaults = {\n  frequency: 440,\n  gains: [0],\n  types: [\"sine\"],\n  compensate: true,\n}\n\nfunction initState (state, ratios) {\n  const gains = state.gains\n  const types = state.types\n  state.gains = ratios.map((_, i) => gains[i % gains.length])\n  state.types = ratios.map((_, i) => types[i % types.length])\n  state.ratios = ratios\n}\n\nfunction updateFrequencies ({ oscs }, { ratios, frequency }, time) {\n  console.log(\"UPDATE FREQS\", ratios, frequency)\n  oscs.forEach((osc, i) => {\n    osc.frequency.setValueAtTime(ratios[i] * frequency, time)\n  })\n}\n\nfunction updateGains ({ amps }, { gains }, time) {\n  amps.forEach((amp, i) => {\n    if (gains[i] !== undefined) amp.gain.setValueAtTime(gains[i], time)\n  })\n}\n\nfunction updateArray (prev, next) {\n  if (next) {\n    const len = prev.length\n    for (var i = 0; i < len; i++) {\n      if (next[i] !== undefined) prev[i] = next[i]\n    }\n  }\n}\n","// # HiHat\nimport { instrument } from \"../synth\"\nimport OscBank from \"../kit/osc-bank\"\nimport Filter from \"../kit/filter\"\nimport Gain from \"../kit/gain\"\nimport GainEnvelope from \"../kit/gain-envelope\"\n\n// A HiHat modeled after the 808 design\n\n// **References**\n// - Synth secrets: https://github.com/micjamking/synth-secrets/blob/master/part-40.md\n\nconst BASE_FQ = 400\nconst RATIOS = [263, 400, 421, 474, 587, 845].map(f => f / BASE_FQ)\n\n/**\n * Create a HiHat\n */\nexport function HiHat (ac, state) {\n  state = Object.assign({}, HiHat.defaults, state)\n\n  // ## Architecture\n  const hihat = instrument(ac, {\n    // six square-wave oscillators\n    bank: [OscBank(ac, RATIOS, state.bank), \"midFilter\"],\n    // band pass filter\n    midFilter: [Filter, \"envelope\"],\n    // AD envelope\n    envelope: [GainEnvelope, \"hiFilter\"],\n    // hipass filter\n    hiFilter: [Filter, \"amp\"],\n    // amplifier\n    amp: [Gain, \"output\"]\n  }).update(state)\n\n  // # API\n  // trigger\n  hihat.trigger = hihat.envelope.trigger\n\n  console.log(hihat)\n\n  return hihat\n}\n\nHiHat.defaults = {\n  bank: {\n    frequency: BASE_FQ,\n    types: [\"square\"],\n    gains: [0.5],\n    compensate: false,\n  },\n  midFilter: {\n    type: \"bandpass\",\n    frequency: 10000,\n  },\n  envelope: {\n    attack: 0.01,\n    decay: 0.1,\n  },\n  hiFilter: {\n    type: \"highpass\",\n    frequency: 8000,\n  },\n  amp: {\n    gain: 0.8,\n  },\n}\n\nexport default HiHat\n","// # Cowbell\n\n// The Cowbell is based on the 808 design:\n\n// > \"the block diagram for the cowbell sound generator in the TR808 is a\n// relatively simple circuit, and uses just two of the six pulse-wave\n// oscillators that provide the basis of the machine's cymbal and hi-hat sounds.\n// The outputs from these pass through a pair of VCAs controlled by a contour\n// generator, and through a band-pass filter that removes the upper and lower\n// partials. Finally, the result is then amplified before reaching the outside\n// world.\"\n\n// Source of all quotes: https://github.com/micjamking/synth-secrets/blob/master/part-41.md\n\n// #### Oscillators\n\n// > \"We should be able to recreate this sound on any synth with two oscillators\n// and a band-pass (...) the sound comprises a pair of tones with fundamental\n// pitches of approximately 587Hz and 845Hz. With a frequency ratio of 1:1.44,\n// these are suitably clangy, and serve Roland's purpose well.\"\n\n// > Firstly, we select two oscillators, and set them with triangle-wave outputs\n// at frequencies of 587Hz and 845Hz\n\n// #### Filter\n\n// > \"then added a band-pass filter, finding that a centre frequency of 2.64kHz\n// worked well. The 12dB-per-octave option sounded a bit flabby, while the\n// 24dB-per-octave cutoff shaped the sound too severely, , so I chose the\n// 12dB-per-octave option and added a little resonance to accentuate the\n// partials close to the centre frequency\"\n\n// #### Envelope\n\n// > \"forms an envelope having abrupt level decay at the initial trailing edge\n// to emphasise attack effect\"\n\n// #### The instrument\nimport { instrument } from \"../synth\"\nimport Gain from \"../kit/gain\"\nimport Osc from \"../kit/osc\"\nimport GainEnvelope from \"../kit/gain-envelope\"\nimport Filter from \"../kit/filter\"\n\n/**\n * Create a Cowbell\n * @param {AudioContext} context\n * @param {Object} config\n * @return {AudioNode} the instrument\n * @example\n * const cowbell = Cowbell(ac)\n * cowbell.trigger(ac.currentTime + 1)\n */\nexport default function Cowbell (ac, state) {\n  if (state) state = Object.assign({}, Cowbell.defaultState, state)\n  else state = Cowbell.defaultState\n\n  const cowbell = instrument(ac, {\n    osc1: [ Osc, \"env1\" ],\n    env1: [ GainEnvelope, \"filter\" ],\n    osc2: [ Osc, \"env2\" ],\n    env2: [ GainEnvelope, \"filter\" ],\n    filter: [ Filter, \"amp\" ],\n    amp: [ Gain, \"output\" ]\n  }).update(state)\n\n  cowbell.trigger = (time) => {\n    cowbell.env1.trigger(time)\n    cowbell.env2.trigger(time)\n  }\n  return cowbell\n}\n\n// The Cowbell default parameters\nCowbell.defaultState = {\n  osc1: {\n    type: \"triangle\",\n    frequency: 587\n  },\n  env1: {\n    gain: 0.6,\n    attack: 0.01,\n    decay: 0.05,\n    sustain: 0,\n  },\n  osc2: {\n    type: \"triangle\",\n    frequency: 845,\n  },\n  env2: {\n    gain: 0.8,\n    attack: 0.1,\n    decay: 0.1,\n  },\n  filter: {\n    type: \"bandpass\",\n    frequency: 2640,\n    Q: 3.5,\n  },\n  amp: {\n    gain: 0.2\n  },\n}\n","// # Conga\nimport { instrument, withDefaults } from \"../synth\"\nimport Osc from \"../kit/osc\"\nimport Pulse from \"../kit/pulse\"\nimport Gain from \"../kit/gain\"\nimport GainEnvelope from \"../kit/gain-envelope\"\n\n/**\n * Create a Conga\n */\nexport default function Conga (ac, config) {\n  const state = withDefaults(config, Conga.defaults)\n  const conga = instrument(ac, {\n    oscillator: [ Osc, \"envelope\" ],\n    envelope: [ GainEnvelope, \"amp\" ],\n    pulse: [ Pulse, \"amp\" ],\n    amp: [ Gain, \"output\" ],\n  }).update(state)\n\n  conga.trigger = conga.envelope.trigger\n\n  return conga\n}\nConga.defaults = {\n  oscillator: {\n    frequency: 310\n  },\n  pulse: {\n    gain: 0.8,\n  },\n  envelope: {\n    decay: 0.31\n  },\n  amp: {\n    gain: 0.4\n  },\n}\n","// # Tom\nimport { instrument, withDefaults } from \"../synth\"\nimport Osc from \"../kit/osc\"\nimport Pulse from \"../kit/pulse\"\nimport Gain from \"../kit/gain\"\nimport GainEnvelope from \"../kit/gain-envelope\"\n\nexport default function Tom (ac, config) {\n  const state = withDefaults(config, Tom.defaults)\n  const tom = instrument(ac, {\n    oscillator: [ Osc, \"envelope\" ],\n    envelope: [ GainEnvelope, \"amp\" ],\n    pulse: [ Pulse, \"amp\" ],\n    amp: [ Gain, \"output\" ],\n  }).update(state)\n\n  tom.trigger = (time) => {\n    tom.pulse.trigger(time)\n    tom.envelope.trigger(time)\n  }\n  return tom\n}\nTom.defaults = {\n  oscillator: {\n    frequency: 165\n  },\n  pulse: {\n    gain: 0.1,\n  },\n  envelope: {\n    decay: 0.31\n  },\n  amp: {\n    gain: 1\n  },\n}\n","// # MonoSynth\nimport { instrument } from \"../synth\"\nimport VCO from \"../kit/vco\"\nimport VCF from \"../kit/vcf\"\nimport GainEnvelope from \"../kit/gain-envelope\"\nimport VCA from \"../kit/vca\"\n\n// A MonoSynth is a basic subtractive synth with one oscillator\n\n/**\n * Create a MonoSynth\n * @param {AudioContext} context\n * @param {Object} [config]\n */\nexport function MonoSynth (ac, state) {\n  state = Object.assign({}, MonoSynth.defaults, state)\n\n  // ## Architecture\n  const synth = instrument(ac, {\n    // One modulated oscillator\n    oscillator: [ VCO, \"vcf\" ],\n    // One filter with envelope\n    vcf: [ VCF, \"envelope\" ],\n    // One gain envelope\n    envelope: [ GainEnvelope, \"amp\" ],\n    // The outut\n    amp: [ VCA, \"output\" ]\n  }).update(state)\n\n  // ## API\n  synth.trigger = (freq, time, dur) => {\n    time = time || ac.currentTime\n    if (freq) {\n      synth.oscillator.frequency.setValueAtTime(freq, time)\n      synth.vcf.frequency.setValueAtTime(freq / 2, time)\n    }\n    synth.vcf.trigger(time, dur)\n    synth.envelope.trigger(time, dur)\n  }\n  return synth\n}\n\n// # Default configuration\nMonoSynth.defaults = {\n  oscillator: {\n    type: \"sawtooth\"\n  },\n  vcf: {\n    type: \"lowpass\",\n    Q: 2,\n    attack: 0.1,\n    octaves: 2,\n    decay: 1,\n  },\n  envelope: {\n    attack: 0.1,\n    decay: 0.5,\n    sustain: 0.8,\n    release: 2,\n  },\n  amp: {\n    gain: 0.5\n  }\n}\n\nexport default MonoSynth\n","// # Feedback Comb Filter\nimport { createAudioNode } from \"../synth\"\nimport Gain from \"./gain\"\n\n// The feedback comb filter can be used as a computational physical model of\n// a series of echoes, exponentially decaying and uniformly spaced in time.\n\n// #### References\n\n// - https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html\n\n/**\n * Create a FeedbackCombFilter\n */\nexport default function FeedbackCombFilter (ac, config) {\n  config = Object.assign({}, FeedbackCombFilter.defaults, config)\n  const feedback = Gain(ac, config)\n  // Create a delay with an extra param\n  const filter = createAudioNode(ac, \"Delay\",\n    FeedbackCombFilter.params, config.maxDelay)\n  filter.resonance = feedback.gain\n  filter.connect(feedback)\n  feedback.connect(filter)\n  return filter.update(config)\n}\nFeedbackCombFilter.params = [\"delayTime\", \"resonance\"]\nFeedbackCombFilter.defaults = {\n  maxDelay: 1,\n  delayTime: 0.1,\n  resonance: 0.5\n}\n","// # Pluck synth\nimport { instrument } from \"../synth\"\nimport Gain from \"../kit/gain\"\nimport Noise from \"../kit/noise\"\nimport FeedbackCombFilter from \"../kit/feedback-comb-filter\"\nimport GainEnvelope from \"../kit/gain-envelope\"\n\n// Poor's man version of Karplus-String string synthesis\n\nexport default function Pluck (ac, config) {\n  const pluck = instrument(ac, {\n    noise: [ Noise, \"envelope\" ],\n    envelope: [ GainEnvelope, \"combFilter\" ],\n    combFilter: [ FeedbackCombFilter, \"amp\" ],\n    amp: [ Gain, \"output\" ],\n  }).update(config)\n\n  pluck.trigger = (freq, time, dur) => {\n    const delay = 1 / freq\n    pluck.combFilter.delayTime.setValueAtTime(delay, time)\n    pluck.envelope.trigger(time)\n  }\n  return pluck\n}\n\nPluck.defaults = {\n  noise: {\n    type: \"white\",\n  },\n  envelope: {\n    attack: 0.1,\n    decay: 0.1,\n  },\n  combFilter: {\n    delayTime: 0.2,\n    resonance: 0.9,\n  }\n}\n","// Tonewheel _aka clonewheel_ synth\nimport { instrument } from \"../synth\"\nimport Gain from \"../kit/gain\"\nimport Pulse from \"../kit/pulse\"\nimport GainEnvelope from \"../kit/gain-envelope\"\nimport OscBank from \"../kit/osc-bank\"\n\n// This **will be** an simple model of a Hammond B3 organ. Reproducing the sound\n// of that instrument is a complex task, I\"ll only recreate a very simplified\n// model. Any sonic resemblance with the original is just coincidence.\n\n// **References**\n\n// https://teichman.org/blog/2011/05/roto.html\n// http://electricdruid.net/technical-aspects-of-the-hammond-organ/\n// http://www.dairiki.org/HammondWiki/OriginalHammondLeslieFaq\n// http://www.stefanv.com/electronics/hammond_drawbar_science.html\n\n// http://electricdruid.net/technical-aspects-of-the-hammond-organ/\nconst RATIOS = [0.5, 1.498823530, 1, 2, 2.997647060, 4, 5.040941178, 5.995294120, 8]\n\n// ## Drawbars\n\n// The sound on a tonewheel Hammond organ is varied through the manipulation of\n// drawbars. A drawbar is a metal slider that controls the volume of a\n// particular sound component, in a similar way to a fader on an audio mixing\n// board. As a drawbar is incrementally pulled out, it increases the volume of\n// its sound. When pushed all the way in, the volume is decreased to zero\n\n// ## Presets\n// http://www.dairiki.org/HammondWiki/PopularDrawbarRegistrations\nconst PRESETS = {\n  gospel: toState(\"88 8000 008\"),\n  blues: toState(\"88 8800 000\"),\n  bluesB: toState(\"88 5324 588\"),\n  booker: toState(\"88 8630 000\"),\n  onions: toState(\"80 8800 008\"),\n  smith: toState(\"88 8000 000\"),\n  mcgriff: toState(\"86 8600 006\"),\n  errol: toState(\"80 0008 888\"),\n  genesis: toState(\"33 6866 330\"),\n}\n\n// Given a preset, return a state fragment\nfunction toState (preset) {\n  if (preset) {\n    const norm = (preset.replace(/[^012345678]/g, \"\") + \"000000000\").slice(0, 9)\n    const gains = norm.split(\"\").map((n) => Math.abs(+n / 8))\n    return {\n      bank: { gains }\n    }\n  }\n}\n\n// ## Instrument\nexport default function Tonewheel (ac, preset) {\n  preset = preset ? toState(preset) : PRESETS[\"smith\"]\n  const state = Object.assign({}, Tonewheel.defaults, preset)\n  // Tonewheel instrument output\n  const tw = instrument(ac, {\n    bank: [OscBank(ac, RATIOS), \"envelope\"],\n    envelope: [GainEnvelope, \"amp\"],\n    click: [Pulse, \"output\"],\n    amp: [Gain, \"output\"],\n  }).update(state)\n\n  tw.setPreset = (preset, time) => {\n    const newState = PRESETS[preset] || toState(preset)\n    tw.update(newState)\n  }\n\n  // API\n  tw.trigger = (freq, time, dur) => {\n    tw.bank.update(freq, time)\n    tw.envelope.trigger(time, dur)\n    return tw\n  }\n\n  return tw\n}\nTonewheel.defaults = {\n  bank: {\n    types: [\"sine\"],\n  },\n  amp: {\n    gain: 0.8,\n  }\n}\n"],"names":["instrument","ac","config","inst","names","Object","keys","forEach","Node","key","to","node","connectWith","connect","update","state","time","currentTime","inspect","reduce","name","createAudioNode","type","params","initParam","value","undefined","plug","target","isFn","setValueAtTime","dest","context","destination","withDefaults","defaults","assign","triggerAdsr","param","adsr","cancelScheduledValues","attack","peak","log","linearRampToValueAtTime","decay","sustain","hold","release","exponentialRampToValueAtTime","Gain","GainEnvelope","env","SILENCE","defaultState","newState","trigger","dur","gain","MonoBuffer","samples","generator","inverse","buffer","createBuffer","sampleRate","data","getChannelData","i","Source","source","Noise","duration","Math","random","noise","loop","start","Sample","sample","onended","disconnect","Pulse","VCA","Osc","osc","VCO","VCF","filter","octaves","base","this","frequency","WaveShaper","curve","oversample","shaper","createWaveShaper","SoftClipper","clipper","drive","createSoftClipperCurve","bind","n","Float32Array","x","tanh","Kick","kick","click","envelope","Filter","Snare","snare","oscEnv","noiseEnv","OscBank","ratios","Error","output","amps","map","conn","oscs","types","bank","gains","initState","_","length","updateFrequencies","updateGains","amp","updateArray","prev","next","len","HiHat","hihat","RATIOS","Cowbell","cowbell","env1","env2","Conga","conga","Tom","tom","pulse","MonoSynth","synth","freq","oscillator","vcf","FeedbackCombFilter","feedback","maxDelay","resonance","Pluck","pluck","delay","combFilter","delayTime","toState","preset","replace","slice","split","abs","Tonewheel","PRESETS","tw","setPreset","o","src","f"],"mappings":"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"}