{"version":3,"file":"synth-kit.js","sources":["../lib/synth.js","../lib/kit/gain.js","../lib/kit/gain-envelope.js","../lib/kit/mono-buffer.js","../lib/kit/source.js","../lib/kit/noise.js","../lib/kit/sample.js","../lib/kit/pulse.js","../lib/kit/vca.js","../lib/kit/osc.js","../lib/kit/vco.js","../lib/kit/vcf.js","../lib/kit/wave-shaper.js","../lib/kit/soft-clipper.js","../lib/instruments/kick.js","../lib/instruments/snare.js","../lib/instruments/hat.js","../lib/kit/filter.js","../lib/instruments/cowbell.js","../lib/instruments/conga.js","../lib/instruments/tom.js","../lib/instruments/monosynth.js","../lib/kit/feedback-comb-filter.js","../lib/instruments/pluck.js"],"sourcesContent":["// const isString = (o) => typeof o === \"string\"\nconst isFn = (o) => typeof o === \"function\"\nconst { exp, E } = Math\n\nexport function ampToGain (amp) {\n  return (exp(amp) - 1) / (E - 1)\n}\n\nexport function instrument (config) {\n  const inst = {}\n  const names = Object.keys(config)\n  names.forEach(key => {\n    const [node, to] = config[key]\n    inst[key] = node\n    if (to === \"output\") connectWith(inst, node)\n    else connect(node, config[to][0])\n  })\n  inst.update = (state) => {\n    if (state) {\n      names.forEach(key => {\n        inst[key].update(state[key])\n      })\n    }\n    return inst\n  }\n  inst.inspect = () => names.reduce((state, name) => {\n    state[name] = inst[name].inspect()\n    return state\n  }, {})\n  return inst\n}\n\nexport function createAudioNode (ac, type, params, initParam) {\n  const node = ac[\"create\" + type](initParam)\n  node.update = (state) => {\n    if (state) {\n      params.forEach(name => {\n        plug(node, name, state[name])\n      })\n    }\n    return node\n  }\n  node.inspect = () => params.reduce((state, name) => {\n    state[name] = inspect(node, name)\n    return state\n  }, {})\n  return node\n}\n\n// Get the value of a node parameter\nexport function inspect (node, name) {\n  const value = node[name]\n  return value && value.value !== undefined ? value.value : value\n}\n\n/**\n * Update a node property with a value. If the property is a parameter and\n * the value is a node, it will connect them\n */\nexport function plug (node, name, value) {\n  const target = node[name]\n  if (isFn(value)) value = value()\n  if (value === undefined || target === undefined) {\n    // ignore\n  } else if (target.value !== undefined) {\n    // it's a parameter\n    if (isFn(value.connect)) {\n      value.connect(target)\n    } else {\n      target.value = value\n      target.setValueAtTime(value, 0)\n    }\n  } else {\n    // replace the old value with a new one\n    node[name] = value\n  }\n}\n\nfunction connect (node, dest) {\n  if (dest) node.connect(dest)\n}\n\n/**\n * Set the output of a node (by creating a new connect function)\n */\nexport function connectWith (inst, node) {\n  inst.connect = (dest) => {\n    if (dest === true) dest = node.context.destination\n    node.connect(dest)\n    return inst\n  }\n}\n\nexport function withDefaults (config, defaults) {\n  return config ? Object.assign({}, defaults, config) : defaults\n}\n\n/**\n * Trigger an ADSR envelope over a param\n */\nexport function triggerAdsr (time, param, adsr) {\n  param.cancelScheduledValues(0)\n\n  // attack phase\n  const attack = adsr.attack || 0.01\n  const peak = adsr.peak || 1\n  param.setValueAtTime(0, time)\n  time += attack\n  console.log(\"attack\", attack, peak, time)\n  param.linearRampToValueAtTime(peak, time)\n\n  // decay phase\n  const decay = adsr.decay || 0.01\n  const sustain = adsr.sustain || 0\n  time += decay\n  param.linearRampToValueAtTime(sustain, time)\n\n  // hold phase\n  const hold = adsr.hold || 0\n  if (hold) {\n    time += hold\n    param.setValueAtTime(sustain, time)\n  }\n\n  const release = time => {\n    if (sustain) {\n      param.setValueAtTime(time, sustain)\n      const release = adsr.release || 0\n      console.log(\"Trigger release\", release, time)\n      time += release\n      param.exponentialRampToValueAtTime(0.00001, time)\n    }\n  }\n\n  // trigger release if hold is specified\n  if (hold) {\n    release(time)\n  }\n\n  return release\n}\n","// # Gain\nimport { createAudioNode } from \"../synth\"\n\n// Gain produces changes in volume\n\n/**\n * Create a Gain node.\n */\nexport default function Gain (ac, state) {\n  return createAudioNode(ac, \"Gain\", Gain.params).update(state)\n}\nGain.params = [\"gain\"]\n","import { triggerAdsr } from \"../synth\"\nimport Gain from \"./gain\"\n\nconst SILENCE = { gain: 0 }\n/**\n * Create a Gain envelope. Any audio source can be connected to an\n * audio envelope.\n *\n * @example\n * const [osc, adsr] = connect(Osc(ac), GainEnvelope(ac))\n * adsr.trigger()\n */\nexport default function GainEnvelope (ac, state) {\n  const env = Gain(ac, SILENCE)\n  state = Object.assign({}, GainEnvelope.defaultState, state)\n\n  env.update = (newState) => {\n    state = Object.assign(state, newState)\n    return env\n  }\n  env.inspect = () => state\n\n  env.trigger = function (time, dur) {\n    if (!time) time = ac.currentTime\n    const release = triggerAdsr(time, env.gain, state)\n    if (dur) release(time + dur)\n    return release\n  }\n  return env\n}\n\nGainEnvelope.params = [\n  \"base\",\n  \"peak\",\n  \"attack\",\n  \"decay\",\n  \"sustain\",\n  \"release\",\n]\n\n// default values\nGainEnvelope.defaultState = {\n  peak: 1,\n  attack: 0.01,\n  decay: 0.2,\n}\n","// # Buffer (Mono)\n\n/**\n * Create a MonoBuffer using a generator function\n */\nexport default function MonoBuffer (ac, samples, generator, inverse = false) {\n  const buffer = ac.createBuffer(1, samples, ac.sampleRate)\n  const data = buffer.getChannelData(0)\n  for (let i = 0; i < samples; i++) {\n    data[i] = generator(inverse ? samples - i : i)\n  }\n  return buffer\n}\n","// # Source\nimport { createAudioNode } from \"../synth\"\n\n// Create a node that plays audio from a buffer\n\n/**\n * Create a (Buffer)Source node\n */\nexport default function Source (ac, buffer, state) {\n  const source = createAudioNode(ac, \"BufferSource\", Source.params)\n  source.update(state)\n  source.buffer = buffer\n  return source\n}\n\nSource.params = [\"detune\", \"loop\", \"loopStart\", \"loopEnd\", \"playbackRate\"]\n","// # Noise\nimport MonoBuffer from \"./mono-buffer\"\nimport Source from \"./source\"\n\n/**\n * Create a Noise oscillator\n *\n * @param {AudioContext} ac\n * @param {Object} [config]\n * - type: the noise type. Can be \"white\" (by default)\n * - duration: the duration in seconds\n * @return {AudioNode} the noise node\n */\nexport default function Noise (ac, config) {\n  config = Object.assign({}, Noise.defaults, config)\n  const samples = config.duration * ac.sampleRate\n  const buffer = MonoBuffer(ac, samples, () => Math.random() * 2 - 1)\n  const noise = Source(ac, buffer, { loop: true })\n  noise.start()\n  return noise\n}\nNoise.defaults = {\n  duration: 1,\n  loop: true\n}\n","// # Sample\nimport Gain from \"./gain\"\nimport Source from \"./source\"\n\n// A sample is a re-triggerable audio buffer source.\n\n/**\n * Create a Sample\n *\n * @param {AudioContext} context\n * @param {AudioBuffer} buffer\n * @param {Object} [state]\n */\nexport default function Sample (ac, buffer, config) {\n  const sample = Gain(ac)\n\n  sample.trigger = (time, dur) => {\n    if (!time) time = ac.currentTime\n    const source = Source(ac, buffer, config)\n    source.connect(sample)\n    source.onended = () => {\n      if (sample.onended) sample.onended()\n      source.disconnect()\n    }\n    source.start(time)\n  }\n  return sample\n}\n\nSample.state = {\n  gain: 0.8\n}\n","// # Pulse\nimport MonoBuffer from \"./mono-buffer\"\nimport Sample from \"./sample\"\n\n/**\n * Create a Pulse audio node\n *\n * @param {AudioContext} ac\n * @param {Object} [config]\n * - type: the pulse type. Can be \"white\" (by default)\n * - duration: the duration in seconds\n * @return {AudioNode} the pulse node\n */\nexport default function Pulse (ac, config) {\n  config = Object.assign({}, Pulse.defaults, config)\n  const samples = config.duration * ac.sampleRate\n  const buffer = MonoBuffer(ac, samples, () => Math.random() * 2 - 1)\n  const pulse = Sample(ac, buffer)\n  return pulse\n}\nPulse.defaults = {\n  duration: 0.001\n}\n","// Voltage controlled amplified\nimport Gain from \"./gain\"\n\n/**\n * Create a VCA\n */\nexport default function VCA (ac, config) {\n  const vca = Gain(ac, config)\n  return vca\n}\n","// # Oscillator\nimport { createAudioNode } from \"../synth\"\n\n/**\n * Create an Oscillator\n * A oscillator is always started\n */\nexport default function Osc (ac, state, start = true) {\n  const osc = createAudioNode(ac, \"Oscillator\", Osc.params)\n  if (start) osc.start(+start)\n  return osc\n}\nOsc.params = [\"type\", \"frequency\", \"detune\"]\n","// # Voltage Controlled Oscillator\nimport Osc from \"./osc\"\n\n/**\n * Create a VCO\n */\nexport default function VCO (ac, config) {\n  return Osc(ac, config)\n}\n","// # Voltage Controlled Filter\nimport { createAudioNode, triggerAdsr } from \"../synth\"\n\n// A voltage controlled filter is a BiquadFilter with a\n// AD (attack-decay) envelope connected to it's frequency\n\n/**\n * Create a VCF\n */\nexport default function VCF (ac, state) {\n  const filter = createAudioNode(ac, \"BiquadFilter\", VCF.params)\n  // set the default parameters so plug work with them\n  filter.attack = 0.01\n  filter.decay = 0.1\n  filter.octaves = 2\n\n  filter.trigger = function (time, dur) {\n    if (!time) time = ac.currentTime\n    this.base = this.frequency.value\n    this.peak = this.base * this.octaves\n    const release = triggerAdsr(time, filter.frequency, filter)\n    if (dur) release(time + dur)\n    return release\n  }\n  return filter.update(state)\n}\nVCF.params = [\"type\", \"frequency\", \"detune\", \"Q\",\n  \"attack\", \"decay\", \"octaves\"]\nVCF.defaults = {\n  type: \"lowpass\",\n  frequency: 880,\n  attack: 0.1,\n  decay: 0.5,\n  octaves: 2\n}\n","// # WaveShaper\n\n/**\n * Create a WaveShaper node.\n */\nexport default function WaveShaper (ac, curve, oversample = \"none\") {\n  const shaper = ac.createWaveShaper()\n  shaper.curve = curve\n  shaper.oversample = oversample\n  return shaper\n}\n","// # SoftClipper\nimport { createAudioNode } from \"../synth\"\nimport WaveShaper from \"./wave-shaper\"\n\n// ## Structure\n// Input -> Gain -> WaveShaper -> Output\n\nlet curve = null\n\n/**\n * Create a SoftClipper\n */\nexport default function SoftClipper (ac, state) {\n  const clipper = createAudioNode(ac, \"Gain\", SoftClipper.params)\n  clipper.drive = clipper.gain\n  if (!curve) curve = createSoftClipperCurve()\n  const shaper = WaveShaper(ac, curve, \"2x\")\n  clipper.connect(shaper)\n  clipper.connect = shaper.connect.bind(shaper)\n  return clipper.update(state)\n}\nSoftClipper.params = [\"drive\"]\n\nfunction createSoftClipperCurve () {\n  const n = 65536\n  const curve = new Float32Array(n)\n  for (let i = 0; i < n; i++) {\n    const x = (i - (n / 2)) / (n / 2)\n    curve[i] = Math.tanh(x)\n  }\n  return curve\n}\n","import { instrument } from \"../synth\"\nimport Osc from \"../kit/osc\"\nimport Gain from \"../kit/gain\"\nimport Pulse from \"../kit/pulse\"\nimport SoftClipper from \"../kit/soft-clipper\"\nimport GainEnvelope from \"../kit/gain-envelope\"\nimport VCF from \"../kit/vcf\"\n\nexport function Kick (ac, state) {\n  state = Object.assign({}, Kick.defaults, state)\n  const kick = instrument({\n    oscillator: [ Osc(ac), \"envelope\" ],\n    click: [ Pulse(ac), \"envelope\" ],\n    envelope: [ GainEnvelope(ac), \"vcf\" ],\n    vcf: [ VCF(ac), \"clipper\" ],\n    clipper: [ SoftClipper(ac), \"amp\" ],\n    amp: [ Gain(ac), \"output\" ],\n  }).update(state)\n\n  kick.trigger = (time) => {\n    kick.click.trigger(time)\n    kick.envelope.trigger(time)\n  }\n\n  return kick\n}\n\nKick.defaults = {\n  oscillator: {\n    type: \"sine\",\n    frequency: 48,\n  },\n  envelope: {\n    attack: 0.1,\n    decay: 0.2,\n  },\n  vcf: {\n    type: \"lowpass\",\n    frequency: 48,\n    envelope: {\n      base: 48,\n      peak: 100,\n      attack: 0.001,\n      decay: 0.60,\n    }\n  },\n  amp: {\n    gain: 1,\n  }\n}\n\nexport default Kick\n","import { instrument } from \"../synth\"\nimport Osc from \"../kit/osc\"\nimport Noise from \"../kit/noise\"\nimport Gain from \"../kit/gain\"\nimport GainEnvelope from \"../kit/gain-envelope\"\n\nexport function Snare (ac, state) {\n  state = Object.assign({}, Snare.defaults, state)\n  const snare = instrument({\n    osc1: [ Osc(ac), \"oscEnv\" ],\n    osc2: [ Osc(ac), \"oscEnv\" ],\n    oscEnv: [ GainEnvelope(ac), \"amp\" ],\n    noise: [ Noise(ac), \"noiseEnv\" ],\n    noiseEnv: [ GainEnvelope(ac), \"amp\" ],\n    amp: [ Gain(ac), \"output\" ]\n  }).update(state)\n\n  snare.trigger = (time) => {\n    snare.oscEnv.trigger(time)\n    snare.noiseEnv.trigger(time)\n  }\n\n  return snare\n}\n\nSnare.defaults = {\n  osc1: {\n    type: \"sine\",\n    frequency: 238,\n  },\n  osc2: {\n    type: \"sine\",\n    frequency: 476,\n  },\n  oscEnv: {\n    gain: 0.5,\n    attack: 0.01,\n    release: 0.4,\n  },\n  noise: {\n    type: \"white\",\n  },\n  noiseEnv: {\n    attack: 0.01,\n    decay: 0.1,\n  },\n  amp: {\n    gain: 0.5,\n  },\n}\n\nexport default Snare\n","import { instrument } from \"../synth\"\nimport Noise from \"../kit/noise\"\nimport Gain from \"../kit/gain\"\nimport GainEnvelope from \"../kit/gain-envelope\"\n\nexport function Hat (ac, state) {\n  state = Object.assign({}, Hat.defaults, state)\n  const snare = instrument({\n    noise: [ Noise(ac), \"envelope\" ],\n    envelope: [ GainEnvelope(ac), \"amp\" ],\n    amp: [ Gain(ac), \"output\" ]\n  }).update(state)\n\n  snare.trigger = snare.envelope.trigger\n\n  return snare\n}\n\nHat.defaults = {\n  noise: {\n    type: \"white\"\n  },\n  envelope: {\n    attack: 0.01,\n    release: 0.1\n  },\n  amp: {\n    gain: 0.1,\n  }\n}\n\nexport default Hat\n","/** @module kit */\nimport { createAudioNode } from \"../synth\"\n\n/**\n * Create a Filter\n * @param {AudioContext} context\n * @param {Object} [config]\n */\nexport default function Filter (ac, state) {\n  return createAudioNode(ac, \"BiquadFilter\", Filter.params).update(state)\n}\nFilter.params = [\"type\", \"frequency\", \"detune\", \"Q\"]\n","// # Cowbell\n\n// The Cowbell is based on the 808 design:\n\n// > \"the block diagram for the cowbell sound generator in the TR808 is a\n// relatively simple circuit, and uses just two of the six pulse-wave\n// oscillators that provide the basis of the machine's cymbal and hi-hat sounds.\n// The outputs from these pass through a pair of VCAs controlled by a contour\n// generator, and through a band-pass filter that removes the upper and lower\n// partials. Finally, the result is then amplified before reaching the outside\n// world.\"\n\n// Source of all quotes: https://github.com/micjamking/synth-secrets/blob/master/part-41.md\n\n// #### Oscillators\n\n// > \"We should be able to recreate this sound on any synth with two oscillators\n// and a band-pass (...) the sound comprises a pair of tones with fundamental\n// pitches of approximately 587Hz and 845Hz. With a frequency ratio of 1:1.44,\n// these are suitably clangy, and serve Roland's purpose well.\"\n\n// > Firstly, we select two oscillators, and set them with triangle-wave outputs\n// at frequencies of 587Hz and 845Hz\n\n// #### Filter\n\n// > \"then added a band-pass filter, finding that a centre frequency of 2.64kHz\n// worked well. The 12dB-per-octave option sounded a bit flabby, while the\n// 24dB-per-octave cutoff shaped the sound too severely, , so I chose the\n// 12dB-per-octave option and added a little resonance to accentuate the\n// partials close to the centre frequency\"\n\n// #### Envelope\n\n// > \"forms an envelope having abrupt level decay at the initial trailing edge\n// to emphasise attack effect\"\n\n// #### The instrument\nimport { instrument } from \"../synth\"\nimport Gain from \"../kit/gain\"\nimport Osc from \"../kit/osc\"\nimport GainEnvelope from \"../kit/gain-envelope\"\nimport Filter from \"../kit/filter\"\n\n/**\n * Create a Cowbell\n * @param {AudioContext} context\n * @param {Object} config\n * @return {AudioNode} the instrument\n * @example\n * const cowbell = Cowbell(ac)\n * cowbell.trigger(ac.currentTime + 1)\n */\nexport default function Cowbell (ac, state) {\n  if (state) state = Object.assign({}, Cowbell.defaultState, state)\n  else state = Cowbell.defaultState\n\n  const cowbell = instrument({\n    osc1: [ Osc(ac), \"env1\" ],\n    env1: [ GainEnvelope(ac), \"filter\" ],\n    osc2: [ Osc(ac), \"env2\" ],\n    env2: [ GainEnvelope(ac), \"filter\" ],\n    filter: [ Filter(ac), \"amp\" ],\n    amp: [ Gain(ac), \"output\" ]\n  }).update(state)\n\n  cowbell.trigger = (time) => {\n    cowbell.env1.trigger(time)\n    cowbell.env2.trigger(time)\n  }\n  return cowbell\n}\n\n// The Cowbell default parameters\nCowbell.defaultState = {\n  osc1: {\n    type: \"triangle\",\n    frequency: 587\n  },\n  env1: {\n    gain: 0.6,\n    attack: 0.01,\n    decay: 0.05,\n    sustain: 0,\n  },\n  osc2: {\n    type: \"triangle\",\n    frequency: 845,\n  },\n  env2: {\n    gain: 0.8,\n    attack: 0.1,\n    decay: 0.1,\n  },\n  filter: {\n    type: \"bandpass\",\n    frequency: 2640,\n    Q: 3.5,\n  },\n  amp: {\n    gain: 0.2\n  },\n}\n","// # Conga\nimport { instrument, withDefaults } from \"../synth\"\nimport Osc from \"../kit/osc\"\nimport Pulse from \"../kit/pulse\"\nimport Gain from \"../kit/gain\"\nimport GainEnvelope from \"../kit/gain-envelope\"\n\nexport default function Conga (ac, config) {\n  const state = withDefaults(config, Conga.defaults)\n  const conga = instrument({\n    oscillator: [ Osc(ac), \"envelope\" ],\n    envelope: [ GainEnvelope(ac), \"amp\" ],\n    pulse: [ Pulse(ac), \"amp\" ],\n    amp: [ Gain(ac), \"output\" ],\n  }).update(state)\n\n  conga.trigger = conga.envelope.trigger\n\n  return conga\n}\nConga.defaults = {\n  oscillator: {\n    frequency: 310\n  },\n  pulse: {\n    gain: 0.8,\n  },\n  envelope: {\n    decay: 0.31\n  },\n  amp: {\n    gain: 0.4\n  },\n}\n","// # Tom\nimport { instrument, withDefaults } from \"../synth\"\nimport Osc from \"../kit/osc\"\nimport Pulse from \"../kit/pulse\"\nimport Gain from \"../kit/gain\"\nimport GainEnvelope from \"../kit/gain-envelope\"\n\nexport default function Tom (ac, config) {\n  const state = withDefaults(config, Tom.defaults)\n  const tom = instrument({\n    oscillator: [ Osc(ac), \"envelope\" ],\n    envelope: [ GainEnvelope(ac), \"amp\" ],\n    pulse: [ Pulse(ac), \"amp\" ],\n    amp: [ Gain(ac), \"output\" ],\n  }).update(state)\n\n  tom.trigger = (time) => {\n    tom.pulse.trigger(time)\n    tom.envelope.trigger(time)\n  }\n  return tom\n}\nTom.defaults = {\n  oscillator: {\n    frequency: 165\n  },\n  pulse: {\n    gain: 0.1,\n  },\n  envelope: {\n    decay: 0.31\n  },\n  amp: {\n    gain: 1\n  },\n}\n","// # MonoSynth\nimport { instrument } from \"../synth\"\nimport VCO from \"../kit/vco\"\nimport VCF from \"../kit/vcf\"\nimport GainEnvelope from \"../kit/gain-envelope\"\nimport VCA from \"../kit/vca\"\n\n// A MonoSynth is a basic subtractive synth with one oscillator\n\n/**\n * Create a MonoSynth\n * @param {AudioContext} context\n * @param {Object} [config]\n */\nexport function MonoSynth (ac, state) {\n  state = Object.assign({}, MonoSynth.defaults, state)\n  const synth = instrument({\n    oscillator: [ VCO(ac), \"vcf\" ],\n    vcf: [ VCF(ac), \"envelope\" ],\n    envelope: [ GainEnvelope(ac), \"amp\" ],\n    amp: [ VCA(ac), \"output\" ]\n  }).update(state)\n\n  synth.trigger = (freq, time, dur) => {\n    time = time || ac.currentTime\n    if (freq) {\n      synth.oscillator.frequency.setValueAtTime(freq, time)\n      synth.vcf.frequency.setValueAtTime(freq / 2, time)\n    }\n    synth.vcf.trigger(time, dur)\n    synth.envelope.trigger(time, dur)\n  }\n  return synth\n}\nMonoSynth.defaults = {\n  oscillator: {\n    type: \"sawtooth\"\n  },\n  vcf: {\n    type: \"lowpass\",\n    Q: 2,\n    attack: 0.1,\n    octaves: 2,\n    decay: 1,\n  },\n  envelope: {\n    attack: 0.1,\n    decay: 0.5,\n    sustain: 0.8,\n    release: 2,\n  },\n  amp: {\n    gain: 0.5\n  }\n}\n\nexport default MonoSynth\n","// # Feedback Comb Filter\nimport { createAudioNode } from \"../synth\"\nimport Gain from \"./gain\"\n\n// The feedback comb filter can be used as a computational physical model of\n// a series of echoes, exponentially decaying and uniformly spaced in time.\n\n// #### References\n\n// - https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html\n\n/**\n * Create a FeedbackCombFilter\n */\nexport default function FeedbackCombFilter (ac, config) {\n  config = Object.assign({}, FeedbackCombFilter.defaults, config)\n  const feedback = Gain(ac, config)\n  // Create a delay with an extra param\n  const filter = createAudioNode(ac, \"Delay\",\n    FeedbackCombFilter.params, config.maxDelay)\n  filter.resonance = feedback.gain\n  filter.connect(feedback)\n  feedback.connect(filter)\n  return filter.update(config)\n}\nFeedbackCombFilter.params = [\"delayTime\", \"resonance\"]\nFeedbackCombFilter.defaults = {\n  maxDelay: 1,\n  delayTime: 0.1,\n  resonance: 0.5\n}\n","// # Pluck synth\nimport { instrument } from \"../synth\"\nimport Gain from \"../kit/gain\"\nimport Noise from \"../kit/noise\"\nimport FeedbackCombFilter from \"../kit/feedback-comb-filter\"\nimport GainEnvelope from \"../kit/gain-envelope\"\n\n// Poor's man version of Karplus-String string synthesis\n\nexport default function Pluck (ac, config) {\n  const pluck = instrument({\n    noise: [ Noise(ac), \"envelope\" ],\n    envelope: [ GainEnvelope(ac), \"combFilter\" ],\n    combFilter: [ FeedbackCombFilter(ac), \"amp\" ],\n    amp: [ Gain(ac), \"output\" ],\n  }).update(config)\n\n  pluck.trigger = (freq, time, dur) => {\n    const delay = 1 / freq\n    pluck.combFilter.delayTime.setValueAtTime(delay, time)\n    pluck.envelope.trigger(time)\n  }\n  return pluck\n}\n\nPluck.defaults = {\n  noise: {\n    type: \"white\",\n  },\n  envelope: {\n    attack: 0.1,\n    decay: 0.1,\n  },\n  combFilter: {\n    delayTime: 0.2,\n    resonance: 0.9,\n  }\n}\n"],"names":["instrument","config","inst","names","Object","keys","forEach","key","node","to","connectWith","connect","update","state","inspect","reduce","name","createAudioNode","ac","type","params","initParam","value","undefined","plug","target","isFn","setValueAtTime","dest","context","destination","withDefaults","defaults","assign","triggerAdsr","time","param","adsr","cancelScheduledValues","attack","peak","log","linearRampToValueAtTime","decay","sustain","hold","release","exponentialRampToValueAtTime","Gain","GainEnvelope","env","SILENCE","defaultState","newState","trigger","dur","currentTime","gain","MonoBuffer","samples","generator","inverse","buffer","createBuffer","sampleRate","data","getChannelData","i","Source","source","Noise","duration","Math","random","noise","loop","start","Sample","sample","onended","disconnect","Pulse","VCA","Osc","osc","VCO","VCF","filter","octaves","base","this","frequency","WaveShaper","curve","oversample","shaper","createWaveShaper","SoftClipper","clipper","drive","createSoftClipperCurve","bind","n","Float32Array","x","tanh","Kick","kick","click","envelope","Snare","snare","oscEnv","noiseEnv","Hat","Filter","Cowbell","cowbell","env1","env2","Conga","conga","Tom","tom","pulse","MonoSynth","synth","freq","oscillator","vcf","FeedbackCombFilter","feedback","maxDelay","resonance","Pluck","pluck","delay","combFilter","delayTime","o"],"mappings":"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"}